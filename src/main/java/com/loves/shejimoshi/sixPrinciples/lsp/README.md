# 里氏替换原则(LSP:Liskov Substitution Principle)
定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。    
  
里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，
反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，
因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。  

### 里氏替换原则为良好的继承定义了一个规范，它包含了4层定义：
 * 子类必须完全实现父类的方法。
 * 子类可以有自己的个性。
 * 覆盖或实现父类的方法时输入参数可以被放大。
 * 覆写或实现父类的方法时输出结果可以被缩小。
  
采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。
即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，
传递不同的子类完成不同的业务逻辑，非常完美。

##########
 
 * 里氏替换原则（六大原则中最文静的姑娘，但却不太招人喜欢）：
   这个原则表达的意思是一个子类应该可以替换掉父类并且可以正常工作。
 * 那么翻译成比较容易理解的话，就是说，子类一般不该重写父类的方法，
   因为父类的方法一般都是对外公布的接口，是具有不可变性的，你不该将一些不该变化的东西给修改掉。
 * 上述只是通常意义上的说法，很多情况下，我们不必太理解里氏替换这个文静的姑娘，
   比如模板方法模式，缺省适配器，装饰器模式等一些设计模式，就完全不搭理这个文静的姑娘。
 * 不过就算如此，如果你真的遇见了不得不重写父类方法的场景，那么请你考虑，
   你是否真的要把这个类作为子类出现在这里，或者说这样做所换来的是否能弥补你失去的东西，
   比如子类无法代替父类工作，那么就意味着如果你的父类可以在某一个场景里工作的很正常，
   那么你的子类当然也应该可以，否则就会出现下述场景。

