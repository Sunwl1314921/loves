package com.loves.shejimoshi.sixPrinciples.dip.version01;

/**
 * @Author ：SunWenLong
 * @Date ：2018/11/22
 */
public interface Read {
    public int getA();

    public int getB();
}
//总结：
//    依赖倒置原则（六大原则中最小鸟依人的姑娘，对抽象的东西非常依赖）：
//这个原则描述的是高层模块不该依赖于低层模块，二者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。
//
//    上面黑色加粗这句话是这个原则的原版描述，我来解释下我自己的理解，
//这个原则描述的是一个现实当中的事实，即实现都是易变的，而只有抽象是稳定的，所以当依赖于抽象时，实现的变化并不会影响客户端的调用。
//
//    比如上述的计算器例子，我们的计算器其实是依赖于数据读取类的，这样做并不是很好，因为如果我的数据不是文件里的了，
//而是在数据库里，这样的话，为了不影响你现有的代码，你就只能将你的Reader类整个改头换面。
//
//    或者还有一种方式就是，你再添加一个DBReader类，然后把你所有使用Reader读取的地方，全部手动替换成DBReader，
//这样其实也还可以接受，那假设我有的从文件读取，有的从数据库读取，有的从XML文件读取，有的从网络中读取，有的从标准的键盘输入读取等等。
//
//    你想怎么办呢？
//
//    所以我们最好的做法就是抽象出一个抽象类或者是接口，来表述数据读取的行为，然后让上面所有的读取方式所实现的类都实现这个接口，
//而我们的客户端，只使用我们定义好的接口，当我们的实现变化时，我只需要设置不同的实际类型就可以了，这样对于系统的扩展性是一个大大的提升。
//
//    让我们原来的Reader改名为FileReader去实现这个接口，这样计算器就依赖于抽象的接口，这个依赖是非常稳定的，
//因为不论你以后要从哪读取数据，你的两个获取数据的方法永远都不会变。
//
//    这样，我们让DBReader，XMLReader，NETReader，StandardOutPutStreamReader等等，
//都可以实现Reader这个接口，而我们的客户端调用依赖于一个Reader，这样不管数据是从哪来的，我们都可以应对自如，
//因为我根本不关心你是什么Reader，我只知道你能让我获得A和B这两个值就行了。
//
//    这便是我们依赖于抽象所得到的灵活性，这也是JAVA语言的动态特性给我们带来的便利，所以我们一定要好好珍惜这个依赖于抽象的姑娘。


